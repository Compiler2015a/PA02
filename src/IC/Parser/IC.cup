package IC.Parser;
import java_cup.runtime.*;

import IC.AST.*;

/* Preliminaries to set up and use the scanner.  */
init with {: 
	scanner.init();
	:};
scan with {: return scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal			ID, CLASS_ID, SEMICOLON, COMMA;

// Keywords
terminal			CLASS_KEYWORD, EXTENDS_KEYWORD, STATIC_KEYWORD, VOID_KEYWORD,
					INT_KEYWORD, BOOLEAN_KEYWORD, STRING_KEYWORD, RETURN_KEYWORD,
					IF_KEYWORD, ELSE_KEYWORD, WHILE_KEYWORD, BREAK_KEYWORD, CONTINUE_KEYWORD,
					THIS_KEYWORD, NEW_KEYWORD, LENGTH_KEYWORD;

// Literals
terminal			TRUE_LITERAL, FALSE_LITERAL, NULL_LITERAL, STRING_LITERAL;
terminal Integer    INTEGER_LITERAL;

// Operators and signs
terminal			LP, RP, LC, RC, LB, RB, DOT, EXCLAMATION_MARK, PLUS, MINUS, MULT,
					DIVIDE, REMINDER, SMALLER_OP, LARGER_OP, SMALLER_EQ_OP, LARGER_EQ_OP,
					EQUALS_OP, NOT_EQUALS_OP, AND_OP, OR_OP, ASSIGN;


// Context terminals
terminal UMINUS;

/* Non terminals */
non terminal            program, classDecl_list, classDecl, classLines_list, type, method_type, 
						method, field, extra_fields, params, extra_params,
						stmnt, stmnt_list, elseStmn, call, staticCall, virtualCall,
						extra_exprs, location, binop, unop, literal;
non terminal Integer    expr;

/* Precedences */
precedence left ELSE_KEYWORD;
precedence left DOT;
precedence left SMALLER_OP, LARGER_OP, SMALLER_EQ_OP, LARGER_EQ_OP, 
				EQUALS_OP, NOT_EQUALS_OP, AND_OP, OR_OP;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, REMINDER; 
precedence left ID;
precedence left UMINUS;
precedence left LC, LP;

/* The grammar */
program ::= classDecl_list;

classDecl_list ::= classDecl classDecl_list | ;

classDecl ::= CLASS_KEYWORD CLASS_ID EXTENDS_KEYWORD CLASS_ID:c LB classLines_list RB
				{: System.out.println("Declaration of class: " + c); :} 
			| CLASS_KEYWORD CLASS_ID:c LB classLines_list RB
				{: System.out.println("Declaration of class: " + c); :} ;
				


classLines_list ::= method classLines_list | field classLines_list | ;

field ::= type ID:f extra_fields
				{: System.out.println("Declaration of field: " + f); :} ;

extra_fields ::= COMMA ID extra_fields | SEMICOLON;

method ::= STATIC_KEYWORD method_type ID:m LP params RP LB stmnt_list RB 
			{:
				System.out.println("Declaration of static method: " + m);
			:}
			| method_type ID:m LP params RP LB stmnt_list RB
			{:
				System.out.println("Declaration of virtual method: " + m);
			:} ; 

params ::= type ID:p extra_params 
			{:
				System.out.println("Parameter: " + p);
			:} | ;

extra_params ::= COMMA type ID:p extra_params
 			{:
				System.out.println("Parameter: " + p);
			:} | ;

type ::= INT_KEYWORD:pt 
		 {:
		 	if (parserAssistingVarables.arrayDimentionCounter == 0)
		 		System.out.println("Primitive data type: " + pt);
		 	else {
		 		System.out.println("Primitive data type: " + parserAssistingVarables.arrayDimentionCounter + "-dimensional array of " + pt);
		 		parserAssistingVarables.arrayDimentionCounter = 0;
		 	}
		 :} |
		 BOOLEAN_KEYWORD:pt 
		 {:
		 	if (parserAssistingVarables.arrayDimentionCounter == 0)
		 		System.out.println("Primitive data type: " + pt);
		 	else {
		 		System.out.println("Primitive data type: " + parserAssistingVarables.arrayDimentionCounter + "-dimensional array of " + pt);
		 		parserAssistingVarables.arrayDimentionCounter = 0;
		 	}
		 :} |
		 STRING_KEYWORD:pt
		 {:
		 	if (parserAssistingVarables.arrayDimentionCounter == 0)
		 		System.out.println("Primitive data type: " + pt);
		 	else {
		 		System.out.println("Primitive data type: " + parserAssistingVarables.arrayDimentionCounter + "-dimensional array of " + pt);
		 		parserAssistingVarables.arrayDimentionCounter = 0;
		 	}
		 :} |
		 CLASS_ID:ct
		 {:
		 	System.out.println("User-defined data type: " + ct);
		 :} |
		 type LC RC
		 {:
		 	parserAssistingVarables.arrayDimentionCounter++;
		 :} ;
method_type ::= type |
				VOID_KEYWORD
				{:
					System.out.println("Primitive data type: void");
				:} ;
			
stmnt_list ::= stmnt stmnt_list  | ; 

stmnt ::= 	location ASSIGN expr SEMICOLON 
			{:
				System.out.println("Assignment statement");
			:} |
			call SEMICOLON
			{:
				System.out.println("Method call statement");
			:} | RETURN_KEYWORD SEMICOLON |
			RETURN_KEYWORD expr SEMICOLON
			{:
				System.out.println("Return statement, with return value");
			:} | 
			IF_KEYWORD LP expr RP stmnt elseStmn
			{:
				System.out.println("If statement");
			:} | 
			WHILE_KEYWORD LP expr RP stmnt 
			{:
				System.out.println("While statement");
			:} | 
			BREAK_KEYWORD SEMICOLON
			{:
				System.out.println("Break statement");
			:} | CONTINUE_KEYWORD SEMICOLON |
			LB stmnt_list RB 
			{:
				System.out.println("Block of statements");
			:} | type ID SEMICOLON | 
			type ID:v ASSIGN expr SEMICOLON
			{:
				System.out.println("Declaration of local variable: " + v + ", with initial value");
			:} ;

elseStmn ::= ELSE_KEYWORD stmnt | ;
			
expr ::=	location | call | THIS_KEYWORD |
			NEW_KEYWORD CLASS_ID:c LP RP
			{:
				System.out.println("Instantiation of class: " + c);
			:} |
			NEW_KEYWORD type LC expr RC
			{:
				System.out.println("Array allocation");
			:} |
			expr DOT LENGTH_KEYWORD
			{:
				System.out.println("Reference to array length");
			:} | expr binop expr | unop expr | literal | LP expr RP;
	
call ::=	staticCall | virtualCall;

staticCall ::= 	CLASS_ID:c DOT:m ID LP RP
				{:
					System.out.println("Call to static method: " + m + ", in class " + c);
				:} |
				CLASS_ID:c DOT ID:m LP expr extra_exprs RP
				{:
					System.out.println("Call to static method: " + m + ", in class " + c);
				:} ;

virtualCall ::= expr DOT ID:m LP RP
				{:
					System.out.println("Call to virtual method: " + m + ", in external scope");
				:} | 
				ID:m LP RP
				{:
					System.out.println("Call to virtual method: " + m);
				:} |
				expr DOT ID:m LP expr extra_exprs RP
				{:
					System.out.println("Call to virtual method: " + m + ", in external scope");
				:} | 
				ID:m LP expr extra_exprs RP
				{:
					System.out.println("Call to virtual method: " + m);
				:} ;

extra_exprs ::=	COMMA expr extra_exprs | ;

location ::= ID:v
			 {:
			 	System.out.println("Reference to variable: " + v);
			 :} |
			 expr DOT ID:v
			 {:
			 	System.out.println("Reference to variable: " + v + ", in external scope");
			 :} | 
			 expr LC expr RC
			 {:
			 	System.out.println("Reference to array");
			 :} ;

binop ::= 	PLUS 
			{:
				System.out.println("Mathematical binary operation: addition");
			:} |
			MINUS
			{:
				System.out.println("Mathematical binary operation: subtraction");
			:} |
			MULT
			{:
				System.out.println("Mathematical binary operation: multiplication");
			:} | DIVIDE | REMINDER | SMALLER_OP
			{:
				System.out.println("Logical binary operation: less than");
			:} |
			LARGER_OP 
			{:
				System.out.println("Logical binary operation: greater than");
			:} |
			SMALLER_EQ_OP
			{:
				System.out.println("Logical binary operation: less than or equal to");
			:} |
			LARGER_EQ_OP
			{:
				System.out.println("Logical binary operation: greater than or equal to");
			:} | EQUALS_OP | 
			NOT_EQUALS_OP
			{:
				System.out.println("Logical binary operation: inequality");
			:} | AND_OP | OR_OP;
			
unop ::=	MINUS %prec UMINUS | EXCLAMATION_MARK;

literal ::= INTEGER_LITERAL:n
			{:
				System.out.println("Integer literal: " + n);
			:} |
			STRING_LITERAL:s
			{:
				System.out.println("String literal: " + s);
			:} |
			TRUE_LITERAL:t
			{:
				System.out.println("Boolean literal: " + t);
			:} |
			FALSE_LITERAL:t
			{:
				System.out.println("Boolean literal: " + t);
			:} | NULL_LITERAL;