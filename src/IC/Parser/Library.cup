package IC.Parser;
import java_cup.runtime.*;
import IC.AST.*;
import java.util.List;
import java.util.ArrayList;

/* Parser code */

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;
	private int arrayDimentionCounter = 0;
	
	private String getStringValueFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getValue().toString();
	}
	
	private int getLineFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getLine();
	}
	
	public LibParser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public void syntax_error(Symbol s) { 
	System.out.println("compiler has detected a syntax error at line " + ((Token)s).getLine() + " column " + ((Token)s).getColumn()+ " value " + ((Token)s).getValue().toString()); 
	}
:}

/* Preliminaries to set up and use the scanner.  */
scan with {: 	
	Symbol s = lexer.next_token();
	return new Token(s.sym, s.value, s.left, s.right); 
	:};

/* Terminals (tokens returned by the scanner). */
terminal			VOID_KEYWORD, INT_KEYWORD, BOOLEAN_KEYWORD, STRING_KEYWORD;
terminal			ID;
terminal			CLASS_KEYWORD, CLASS_ID, STATIC_KEYWORD;
terminal            LP, RP, LB, RB, LC, RC, COMMA, SEMICOLON;

/* Non terminals */
non terminal epsilon;
non terminal Program program;
non terminal ICClass libic;
non terminal LibraryMethod libmethod;
non terminal List<Method> libmethod_list_inter, libmethod_list;
non terminal List<Formal> formal_list_inter, formal_list, extra_formals;
non terminal Formal formal;
non terminal Type type, method_type;

/* Precedences */
precedence left ID;
precedence left LC, LP, LB;

/* The grammar */
program ::= libic:lib
		{: List<ICClass> list = new ArrayList<ICClass>(); list.add(lib); RESULT = new Program(list); :}
;

libic ::= CLASS_KEYWORD:ck CLASS_ID:cid LB libmethod_list_inter:ml RB
		{: if(getStringValueFromToken(cid).equals("Library")) 
			{ RESULT = new ICClass(getLineFromToken(ck), getStringValueFromToken(cid), null,
			ml); } else { RESULT = null; } :}
;

libmethod_list_inter ::= epsilon
		{: RESULT = new ArrayList<Method>(); :}
		| libmethod_list:ml
		{: RESULT = ml; :}
;

libmethod_list ::= libmethod:m
		{: List<Method> list = new ArrayList<Method>(); list.add(m); RESULT = list; :}
		| libmethod_list:ml libmethod:m
		{: ml.add(m); RESULT = ml; :}
;

libmethod ::= STATIC_KEYWORD method_type:mt ID:id LP formal_list_inter:fl RP SEMICOLON
		{: RESULT = new LibraryMethod(mt, getStringValueFromToken(id), fl); :}
;

method_type ::= VOID_KEYWORD:v
		{: RESULT = new PrimitiveType(getLineFromToken(v), IC.DataTypes.VOID); :}
		| type:t
		{: RESULT = t; :}
;

type ::= type:t LC RC
		{: t.incrementDimension(); RESULT = t; :}
		| INT_KEYWORD:intKey
		{: RESULT = new PrimitiveType(getLineFromToken(intKey), IC.DataTypes.INT); :}
		| BOOLEAN_KEYWORD:boolKey
		{: RESULT = new PrimitiveType(getLineFromToken(boolKey), IC.DataTypes.BOOLEAN); :}
		| STRING_KEYWORD:strKey
		{: RESULT = new PrimitiveType(getLineFromToken(strKey), IC.DataTypes.STRING); :}
		| CLASS_ID:c
		{: RESULT = new UserType(getLineFromToken(c), getStringValueFromToken(c)); :}
;

formal_list_inter ::= epsilon
		{: RESULT = new ArrayList<Formal>(); :}
		| formal_list:fl
		{: RESULT =  fl; :}
;

formal_list ::= formal:f extra_formals:ef 
		{: ef.add(0, f); RESULT = ef; :} 
;

extra_formals ::= epsilon
		{: RESULT = new ArrayList<Formal>(); :}
		| COMMA formal:f extra_formals:ef
		{: ef.add(0, f); RESULT = ef; :} 
;

formal ::= type:t ID:fName
		{: RESULT = new Formal(t, getStringValueFromToken(fName)); :}
;

epsilon ::=
		{: :}
;