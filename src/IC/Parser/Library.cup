package IC.Parser;
import java_cup.runtime.*;
import IC.AST.*;
import java.util.List;
import java.util.ArrayList;

/* Parser code */

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;
	private int arrayDimentionCounter = 0;
	
	private String getStringValueFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getValue().toString();
	}
	
	private int getLineFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getLine();
	}
	
	public LibParser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
:}

/* Preliminaries to set up and use the scanner.  */
scan with {: 	
	Symbol s = lexer.next_token();
	return new Token(s.sym, s.value, s.left, s.right); 
	:};

/* Terminals (tokens returned by the scanner). */
terminal			VOID_KEYWORD, INT_KEYWORD, BOOLEAN_KEYWORD, STRING_KEYWORD;
terminal			ID;
terminal			CLASS_KEYWORD, CLASS_ID, EXTENDS_KEYWORD, STATIC_KEYWORD;
terminal            LP, RP, LB, RB, LC, RC, COMMA, SEMICOLON;

/* Non terminals */
non terminal Type type, method_type;
non terminal List<Formal> formal_list, extra_formals;
non terminal Formal formal;
non terminal Method method;
non terminal List<Method> method_list;
non terminal ICClass classDecl;
non terminal List<ICClass> classDecl_list;
non terminal Program program;
/* non terminal Integer    expr, term, factor; */

/* The grammar */
program ::= classDecl_list:cl
			{: RESULT = new Program(cl); :}
;

classDecl_list ::= classDecl:c
			{: List<ICClass> list = new ArrayList<ICClass>(); list.add(c); RESULT = list; :}
			| classDecl_list:cl classDecl:c
			{: cl.add(c); RESULT = cl; :}
;

classDecl ::= CLASS_KEYWORD CLASS_ID:cid EXTENDS_KEYWORD CLASS_ID:cex LB method_list:ml RB
			{: RESULT = new ICClass(getLineFromToken(cid), getStringValueFromToken(cid) , getStringValueFromToken(cex), null, /* SHOULDNT BE NULL IN IC.cup */
			ml); :}
			| CLASS_KEYWORD CLASS_ID:cid LB method_list:ml RB /*Library has no need for (field|method)* */
			{: RESULT = new ICClass(getLineFromToken(cid), getStringValueFromToken(cid) , null, /* SHOULDNT BE NULL IN IC.cup */
			ml); :}
; 
			
method_list ::= method:m
		{: List<Method> list = new ArrayList<Method>(); list.add(m); RESULT = list; :}
		| method_list:ml method:m 
		{: ml.add(m); RESULT = ml; :}
;	
	
method ::= STATIC_KEYWORD method_type:t ID:id LP formal_list:fl RP SEMICOLON /* LB stmnt_list RB */
			{: RESULT = new StaticMethod(t, getStringValueFromToken(id), fl, null); :} /* statement list not null in IC.cup */
			| method_type:t ID:id LP formal_list:fl RP SEMICOLON /* LB stmnt_list RB; */
			{: RESULT = new LibraryMethod(t, getStringValueFromToken(id), fl); :} /* statement list not null in IC.cup */
;
			
method_type ::= VOID_KEYWORD:v
		{: RESULT = new PrimitiveType(getLineFromToken(v), IC.DataTypes.VOID); :}
		| type:t
		{: RESULT = t; :}
;
			
type ::= type:t LC RC
		{: t.incrementDimension(); RESULT = t; :}
		| INT_KEYWORD:intKey
		{: RESULT = new PrimitiveType(getLineFromToken(intKey), IC.DataTypes.INT); :}
		| BOOLEAN_KEYWORD:boolKey
		{: RESULT = new PrimitiveType(getLineFromToken(boolKey), IC.DataTypes.BOOLEAN); :}
		| STRING_KEYWORD:strKey
		{: RESULT = new PrimitiveType(getLineFromToken(strKey), IC.DataTypes.STRING); :}
		| CLASS_ID:c
		{: RESULT = new UserType(getLineFromToken(c), getStringValueFromToken(c)); :}
;
	
formal_list ::= formal:f extra_formals:ef 
				{: ef.add(0, f); RESULT = ef; :} 
				| 
				{: RESULT = new ArrayList<Formal>(); :}
;

extra_formals ::= COMMA formal:f extra_formals:ef
				 {: ef.add(0, f); RESULT = ef; :} 
				 | 
				 {: RESULT = new ArrayList<Formal>(); :}
;

formal ::= type:t ID:fName
		{: RESULT = new Formal(t, getStringValueFromToken(fName)); :}
;
	
/* stmnt_list ::= stmnt_list stmnt | stmnt; */
