package IC.Parser;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import IC.AST.*;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;
	private int arrayDimentionCounter = 0;
	
	private String getStringValueFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getValue().toString();
	}
	
	private Object getValueFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getValue();
	}
	
	private int getLineFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getLine();
	}
	
	public parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	protected class ClassLines
	{
		public ClassLines() 
		{
			methods = new ArrayList<Method>(); 
			new ArrayList<Field>();
		}
		public List<Method> methods;
		public List<Field> fields;
	} 
:}

scan with 
{: 
	Symbol s = lexer.next_token();
	return new Token(s.sym, s.value, s.left, s.right);
:};

/* Terminals (tokens returned by the scanner). */
terminal			ID, CLASS_ID, SEMICOLON, COMMA;

// Keywords
terminal			CLASS_KEYWORD, EXTENDS_KEYWORD, STATIC_KEYWORD, VOID_KEYWORD,
					INT_KEYWORD, BOOLEAN_KEYWORD, STRING_KEYWORD, RETURN_KEYWORD,
					IF_KEYWORD, ELSE_KEYWORD, WHILE_KEYWORD, BREAK_KEYWORD, CONTINUE_KEYWORD,
					THIS_KEYWORD, NEW_KEYWORD, LENGTH_KEYWORD;

// Literals
terminal			TRUE_LITERAL, FALSE_LITERAL, NULL_LITERAL, STRING_LITERAL;
terminal Integer    INTEGER_LITERAL;

// Operators and signs
terminal			LP, RP, LC, RC, LB, RB, DOT, EXCLAMATION_MARK, PLUS, MINUS, MULT,
					DIVIDE, REMINDER, SMALLER_OP, LARGER_OP, SMALLER_EQ_OP, LARGER_EQ_OP,
					EQUALS_OP, NOT_EQUALS_OP, AND_OP, OR_OP, ASSIGN;


// Context terminals
terminal UMINUS;

/* Non terminals */
non terminal Program program;
non terminal List<ICClass> icClass_list;
non terminal ICClass icClass;
non terminal ClassLines classLines_list;
non terminal List<Field> fields;
non terminal List<String> extra_fields;
non terminal Method method;
non terminal List<Formal> formal_list, extra_formals;
non terminal Formal formal;
non terminal Type type, method_type;
non terminal List<Statement> stmnt_list; 
non terminal Statement stmnt, elseStmn;
non terminal Expression expr;
non terminal Call call;
non terminal StaticCall staticCall;
non terminal VirtualCall virtualCall;
non terminal List<Expression> arguments, extra_arguments;
non terminal Location location;
non terminal IC.BinaryOps binop;
non terminal IC.UnaryOps unop;
non terminal Literal literal;




/* Precedences */
precedence left ELSE_KEYWORD;
precedence left DOT;
precedence left SMALLER_OP, LARGER_OP, SMALLER_EQ_OP, LARGER_EQ_OP, 
				EQUALS_OP, NOT_EQUALS_OP, AND_OP, OR_OP;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, REMINDER; 
precedence left ID;
precedence left UMINUS;
precedence left LC, LP;

/* The grammar */
program ::= icClass_list:icCl
			{: RESULT = new Program(icCl); :}
;

icClass_list ::= icClass_list:icCl icClass:icC
				 {: icCl.add(icC); RESULT = icCl; :}
  				 |
  				 {: RESULT = new ArrayList<ICClass>(); :}
;

icClass ::= CLASS_KEYWORD:class_key CLASS_ID:cName EXTENDS_KEYWORD CLASS_ID:superCName LB classLines_list:clines RB
			{: RESULT = new ICClass(getLineFromToken(class_key), getStringValueFromToken(cName), 
									getStringValueFromToken(superCName), clines.fields, clines.methods); :} 
			| CLASS_KEYWORD:class_key CLASS_ID:cName LB classLines_list:clines RB
			{: RESULT = new ICClass(getLineFromToken(class_key), getStringValueFromToken(cName), 
									null, clines.fields, clines.methods); :}
;				


classLines_list ::= classLines_list:clines method:m
					{: clines.methods.add(m); RESULT = clines; :}
					| classLines_list:clines fields:fl
					{: clines.fields.addAll(fl); RESULT = clines; :}
					| 
					{: RESULT = new ClassLines(); :}
;

fields ::=  type:t ID:fName extra_fields:fNamesl
			{: 
				fNamesl.add(0, getStringValueFromToken(fName));
				List<Field> fields_list = new ArrayList<Field>();
				for (int i = 0; i < fNamesl.size(); i++)
					fields_list.add(new Field(t, fNamesl.get(i))); 
				RESULT = fields_list; 
			:}
;

extra_fields ::= COMMA ID:fName extra_fields:fNamesl
				 {: 
				 	fNamesl.add(0, getStringValueFromToken(fName));
				 	RESULT = fNamesl;
				 :}
 				| SEMICOLON
 				{: RESULT = new ArrayList<String>(); :}
;

method ::= STATIC_KEYWORD method_type:t ID:mName LP formal_list:fl RP LB stmnt_list:sl RB 
			{: RESULT = new StaticMethod(t, getStringValueFromToken(mName), fl, sl); :}
			| method_type:t ID:mName LP formal_list:fl RP LB stmnt_list:sl RB
			{: RESULT = new VirtualMethod(t, getStringValueFromToken(mName), fl, sl); :}
; 

formal_list ::= formal:f extra_formals:ef 
				{: ef.add(0, f); RESULT = ef; :} 
				| 
				{: RESULT = new ArrayList<Formal>(); :}
;

extra_formals ::= COMMA formal:f extra_formals:ef
				 {: ef.add(0, f); RESULT = ef; :} 
				 | 
				 {: RESULT = new ArrayList<Formal>(); :}
;

formal ::= type:t ID:fName
		{: RESULT = new Formal(t, getStringValueFromToken(fName)); :}
;

method_type ::= VOID_KEYWORD:v
		{: RESULT = new PrimitiveType(getLineFromToken(v), IC.DataTypes.VOID); :}
		| type:t
		{: RESULT = t; :}
;

type ::= type:t LC RC
		{: t.incrementDimension(); RESULT = t; :}
		| INT_KEYWORD:intKey
		{: RESULT = new PrimitiveType(getLineFromToken(intKey), IC.DataTypes.INT); :}
		| BOOLEAN_KEYWORD:boolKey
		{: RESULT = new PrimitiveType(getLineFromToken(boolKey), IC.DataTypes.BOOLEAN); :}
		| STRING_KEYWORD:strKey
		{: RESULT = new PrimitiveType(getLineFromToken(strKey), IC.DataTypes.STRING); :}
		| CLASS_ID:c
		{: RESULT = new UserType(getLineFromToken(c), getStringValueFromToken(c)); :}
;
			
stmnt_list ::= stmnt_list:sl stmnt:s
	 	{: sl.add(s); RESULT = sl; :}
		| 
		{: RESULT = new ArrayList<Statement>(); :}
; 

stmnt ::= 	location:l ASSIGN expr:exp SEMICOLON 
			{: RESULT = new Assignment(l, exp); :} |
			call:c SEMICOLON
			{: RESULT = new CallStatement(c); :} |
			RETURN_KEYWORD:ret_key SEMICOLON
			{: RESULT = new Return(getLineFromToken(ret_key), null); :} |
			RETURN_KEYWORD:ret_key expr:exp SEMICOLON
			{: RESULT = new Return(getLineFromToken(ret_key), exp); :} |
			IF_KEYWORD LP expr:condExp RP stmnt:doStmn elseStmn:eStmn
			{: RESULT = new If(condExp, doStmn, eStmn); :} |
			WHILE_KEYWORD LP expr:condExp RP stmnt:doStmn 
			{: RESULT = new If(condExp, doStmn); :} |
			BREAK_KEYWORD:break_key SEMICOLON
			{: RESULT = new Break(getLineFromToken(break_key)); :} |
			CONTINUE_KEYWORD:continue_key SEMICOLON
			{: RESULT = new Continue(getLineFromToken(continue_key)); :} |
			LB:lb stmnt_list:sl RB 
			{: RESULT = new StatementsBlock(getLineFromToken(lb), sl); :} |
			type:t ID:vName ASSIGN expr:exp SEMICOLON
			{: RESULT = new LocalVariable(t, getStringValueFromToken(vName), exp); :}
;

elseStmn ::= ELSE_KEYWORD stmnt:s {: RESULT = s; :} | {: RESULT = null; :} ;
			
expr ::=	location:l {: RESULT = l; :} | call:c {: RESULT = c; :} | 
			THIS_KEYWORD:ths_key
			{: RESULT = new This(getLineFromToken(ths_key)); :} |
			NEW_KEYWORD:n_key CLASS_ID:c LP RP
			{: RESULT = new NewClass(getLineFromToken(n_key), getStringValueFromToken(c)); :} |
			NEW_KEYWORD type:t LC expr:exp RC
			{: RESULT = new NewArray(t, exp); :} |
			expr:exp DOT LENGTH_KEYWORD
			{: RESULT = new Length(exp); :} | 
			expr:exp1 binop:bOp expr:exp2
			{: RESULT = new LogicalBinaryOp(exp1, bOp, exp2); :} | 
			unop:uOp expr:exp
			{: RESULT = new LogicalUnaryOp(uOp, exp); :} | 
			literal:l {: RESULT = l; :} | LP expr:exp RP {: RESULT = exp; :}
;
	
call ::=	staticCall:sc {: RESULT = sc; :} | virtualCall:vc {: RESULT = vc; :};

staticCall ::= 	CLASS_ID:c DOT ID:m LP arguments:args RP
				{: RESULT = new StaticCall(getLineFromToken(c), getStringValueFromToken(c), getStringValueFromToken(m), args); :}
;

virtualCall ::= expr:exp DOT ID:m LP arguments:args RP
				{: RESULT = new VirtualCall(exp.getLine(), exp, getStringValueFromToken(m), args); :} | 
				ID:m LP arguments:args RP
				{: RESULT = new VirtualCall(getLineFromToken(m), null, getStringValueFromToken(m), args); :}
;

arguments ::=	expr:exp extra_arguments:eArgs 
				{: eArgs.add(0, exp); RESULT = eArgs; :}	
				| 
				{: RESULT = new ArrayList<Expression>(); :}				
;

extra_arguments ::= COMMA expr:exp extra_arguments:eArgs
				{: eArgs.add(0, exp); RESULT = eArgs; :}	
				| 
				{: RESULT = new ArrayList<Expression>(); :}				
;

location ::= ID:vName
			 {: RESULT = new VariableLocation(getLineFromToken(vName), getStringValueFromToken(vName)); :} |
			 expr:exp DOT ID:vName
			 {: RESULT = new VariableLocation(getLineFromToken(vName), exp, getStringValueFromToken(vName)); :} | 
			 expr:exp LC expr:ind_exp RC
			 {: RESULT = new ArrayLocation(exp, ind_exp); :} 
;

binop ::= 	PLUS {: RESULT = IC.BinaryOps.PLUS; :} | MINUS {: RESULT = IC.BinaryOps.MINUS; :} |
			MULT {: RESULT = IC.BinaryOps.MULTIPLY; :} | DIVIDE {: RESULT = IC.BinaryOps.DIVIDE; :} |
			REMINDER {: RESULT = IC.BinaryOps.MOD; :} | SMALLER_OP {: RESULT = IC.BinaryOps.LT; :} |
			LARGER_OP {: RESULT = IC.BinaryOps.GT; :} | SMALLER_EQ_OP {: RESULT = IC.BinaryOps.LTE; :} |
			LARGER_EQ_OP {: RESULT = IC.BinaryOps.GTE; :} | EQUALS_OP {: RESULT = IC.BinaryOps.EQUAL; :} | 
			NOT_EQUALS_OP {: RESULT = IC.BinaryOps.NEQUAL; :} | 
			AND_OP {: RESULT = IC.BinaryOps.LAND; :} | OR_OP {: RESULT = IC.BinaryOps.LOR; :};
			
unop ::=	MINUS {: RESULT = IC.UnaryOps.UMINUS; :} %prec UMINUS | 
			EXCLAMATION_MARK {: RESULT = IC.UnaryOps.LNEG; :};

literal ::= INTEGER_LITERAL:n
			{: RESULT = new Literal(getLineFromToken(n), IC.LiteralTypes.INTEGER, getValueFromToken(n)); :} |
			STRING_LITERAL:s
			{: RESULT = new Literal(getLineFromToken(s), IC.LiteralTypes.STRING, getValueFromToken(s)); :} |
			TRUE_LITERAL:t
			{: RESULT = new Literal(getLineFromToken(t), IC.LiteralTypes.TRUE, getValueFromToken(t)); :} |
			FALSE_LITERAL:f
			{: RESULT = new Literal(getLineFromToken(f), IC.LiteralTypes.FALSE, getValueFromToken(f)); :} |
			NULL_LITERAL:n
			{: RESULT = new Literal(getLineFromToken(n), IC.LiteralTypes.NULL, getValueFromToken(n)); :}
;