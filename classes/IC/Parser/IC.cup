package IC.Parser;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import IC.AST.*;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;
	private int arrayDimentionCounter = 0;
	
	private String getValueFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getValue().toString();
	}
	
	private int getLineFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getLine();
	}
	
	public parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
:}

scan with 
{: 
	Symbol s = lexer.next_token();
	return new Token(s.sym, s.value, s.left, s.right);
:};

/* Terminals (tokens returned by the scanner). */
terminal			ID, CLASS_ID, SEMICOLON, COMMA;

// Keywords
terminal			CLASS_KEYWORD, EXTENDS_KEYWORD, STATIC_KEYWORD, VOID_KEYWORD,
					INT_KEYWORD, BOOLEAN_KEYWORD, STRING_KEYWORD, RETURN_KEYWORD,
					IF_KEYWORD, ELSE_KEYWORD, WHILE_KEYWORD, BREAK_KEYWORD, CONTINUE_KEYWORD,
					THIS_KEYWORD, NEW_KEYWORD, LENGTH_KEYWORD;

// Literals
terminal			TRUE_LITERAL, FALSE_LITERAL, NULL_LITERAL, STRING_LITERAL;
terminal Integer    INTEGER_LITERAL;

// Operators and signs
terminal			LP, RP, LC, RC, LB, RB, DOT, EXCLAMATION_MARK, PLUS, MINUS, MULT,
					DIVIDE, REMINDER, SMALLER_OP, LARGER_OP, SMALLER_EQ_OP, LARGER_EQ_OP,
					EQUALS_OP, NOT_EQUALS_OP, AND_OP, OR_OP, ASSIGN;


// Context terminals
terminal UMINUS;

/* Non terminals */
non terminal            program, icClass_list, icClass, classLines_list, type, method_type, 
						method, fields, extra_fields, formal, formal_list,
						stmnt, stmnt_list, elseStmn, call, staticCall, virtualCall,
						extra_exprs, location, binop, unop, literal;
non terminal Integer    expr;

/* Precedences */
precedence left ELSE_KEYWORD;
precedence left DOT;
precedence left SMALLER_OP, LARGER_OP, SMALLER_EQ_OP, LARGER_EQ_OP, 
				EQUALS_OP, NOT_EQUALS_OP, AND_OP, OR_OP;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, REMINDER; 
precedence left ID;
precedence left UMINUS;
precedence left LC, LP;

/* The grammar */
program ::= icClass_list:icCl
			{: RESULT = new Program((List<ICClass>)icCl); :}
;

icClass_list ::= icClass_list:icCl icClass:icC
				 {: ((List<ICClass>)icCl).add((ICClass)icC); RESULT = classes; :}
  				 |
  				 {: RESULT = new ArrayList<ICClass>(); :}
;

icClass ::= CLASS_KEYWORD:class_key CLASS_ID:cName EXTENDS_KEYWORD CLASS_ID:superCName LB classLines_list:clines RB
			{: RESULT = new ICClass(getLineFromToken(class_key), getValueFromToken(cName), 
									getValueFromToken(superCName), ((ClassLines)clines).fields, ((ClassLines)clines).methods); :} 
			| CLASS_KEYWORD CLASS_ID:c LB classLines_list RB
			{: RESULT = new ICClass(getLineFromToken(class_key), getValueFromToken(cName), 
									null, ((ClassLines)clines).fields, ((ClassLines)clines).methods); :}
				


classLines_list ::= classLines_list:clines method:m
					{: ((ClassLines)clines).methods.add((Method)m); RESULT = clines; :}
					| classLines_list:clines fields:fl
					{: ((ClassLines)clines).fields.addll((List<Field>)fl); RESULT = clines; :}
					| 
					{: RESULT = new ClassLines()
						{
							public List<Method> methods = new ArrayList<Method>();
							public List<Field> fields = new ArrayList<Field>();
						} 
					:}
;

fields ::=  type:t ID:fName extra_fields:fNamesl
			{: 
				List<String> fields_names_list = (List<String>)fNamesl;
				fields_names_list.add(0, getValueFromToken(fName));
				fields_list = new ArrayList<Field>();
				for (int i = 0; i < fields_names_list.size(); i++)
					fields_list.add(new Field((type)t, fields_names_list.get(i))); 
				RESULT = fields_list; 
			:}
;

extra_fields ::= COMMA ID:fName extra_fields:fNamesl
				 {: 
				 	List<String> fields_names_list = (List<Field>)fNamesl;
				 	fields_names_list.add(0, getValueFromToken(fName));
				 	RESULT = fields_names_list;
				 :}
 				| SEMICOLON
 				{: RESULT = new ArrayList<String>(); :}
;

method ::= STATIC_KEYWORD method_type ID:m LP formal_list RP LB stmnt_list RB 
			{:
				System.out.println("Declaration of static method: " + m);
			:}
			| method_type ID:m LP formal_list RP LB stmnt_list RB
			{:
				System.out.println("Declaration of virtual method: " + m);
			:} ; 

formal_list ::= 
		formal_list:fl COMMA formal:f
		{: ((List<Formal>)fl).add((Formal)f); RESULT = fl; :}
		|
		{: RESULT = new ArrayList<Formal>(); :}
;

formal ::= type:t ID:formalName
		{: RESULT = new Formal((Type)t, getValueFromToken(formalName)); :}
;

type ::= INT_KEYWORD:intKey
		{: RESULT = new PrimitiveType(getLineFromToken(intKey), DataTypes.INT); :}
		| BOOLEAN_KEYWORD:boolKey
		{: RESULT = new PrimitiveType(getLineFromToken(boolKey), DataTypes.BOOLEAN); :}
		| STRING_KEYWORD:strKey
		{: RESULT = new PrimitiveType(getLineFromToken(strKey), DataTypes.STRING); :}
		| CLASS_ID:c
		{: RESULT = new UserType(getLineFromToken(c), getValueFromToken(c)); :}
		| type:t LC RC
		{: RESULT = ((Type)t).incrementDimension(); :}
;

method_type ::= VOID_KEYWORD:v
		{: RESULT = new PrimitiveType(getLineFromToken(v), DataTypes.VOID); :}
		| type:t
		{: RESULT = t; :}
;
			
stmnt_list ::= stmnt_list:sl stmnt:s
	 	{: ((List<Statement>)sl).add((Statement)s); RESULT = sl; :}
		| 
		{: RESULT = new ArrayList<Statement>(); :}
; 

stmnt ::= 	location:l ASSIGN expr SEMICOLON 
			{:
				RESULT = new Location(l.getLine()); 
			:} |
			call:c SEMICOLON
			{:
				RESULT = new CallStatement(c);
			:} | RETURN_KEYWORD SEMICOLON |
			RETURN_KEYWORD expr SEMICOLON
			{:
				System.out.println("Return statement, with return value");
			:} | 
			IF_KEYWORD LP expr RP stmnt elseStmn
			{:
				System.out.println("If statement");
			:} | 
			WHILE_KEYWORD LP expr RP stmnt 
			{:
				System.out.println("While statement");
			:} | 
			BREAK_KEYWORD SEMICOLON
			{:
				System.out.println("Break statement");
			:} | CONTINUE_KEYWORD SEMICOLON |
			LB stmnt_list RB 
			{:
				System.out.println("Block of statements");
			:} | type ID SEMICOLON | 
			type ID:v ASSIGN expr SEMICOLON
			{:
				System.out.println("Declaration of local variable: " + v + ", with initial value");
			:} ;

elseStmn ::= ELSE_KEYWORD stmnt | ;
			
expr ::=	location | call | THIS_KEYWORD |
			NEW_KEYWORD CLASS_ID:c LP RP
			{:
				System.out.println("Instantiation of class: " + c);
			:} |
			NEW_KEYWORD type LC expr RC
			{:
				System.out.println("Array allocation");
			:} |
			expr DOT LENGTH_KEYWORD
			{:
				System.out.println("Reference to array length");
			:} | expr binop expr | unop expr | literal | LP expr RP;
	
call ::=	staticCall | virtualCall;

staticCall ::= 	CLASS_ID:c DOT:m ID LP RP
				{:
					System.out.println("Call to static method: " + m + ", in class " + c);
				:} |
				CLASS_ID:c DOT ID:m LP expr extra_exprs RP
				{:
					System.out.println("Call to static method: " + m + ", in class " + c);
				:} ;

virtualCall ::= expr DOT ID:m LP RP
				{:
					System.out.println("Call to virtual method: " + m + ", in external scope");
				:} | 
				ID:m LP RP
				{:
					System.out.println("Call to virtual method: " + m);
				:} |
				expr DOT ID:m LP expr extra_exprs RP
				{:
					System.out.println("Call to virtual method: " + m + ", in external scope");
				:} | 
				ID:m LP expr extra_exprs RP
				{:
					System.out.println("Call to virtual method: " + m);
				:} ;

extra_exprs ::=	COMMA expr extra_exprs | ;

location ::= ID:v
			 {:
			 	System.out.println("Reference to variable: " + v);
			 :} |
			 expr DOT ID:v
			 {:
			 	System.out.println("Reference to variable: " + v + ", in external scope");
			 :} | 
			 expr LC expr RC
			 {:
			 	System.out.println("Reference to array");
			 :} ;

binop ::= 	PLUS 
			{:
				System.out.println("Mathematical binary operation: addition");
			:} |
			MINUS
			{:
				System.out.println("Mathematical binary operation: subtraction");
			:} |
			MULT
			{:
				System.out.println("Mathematical binary operation: multiplication");
			:} | DIVIDE | REMINDER | SMALLER_OP
			{:
				System.out.println("Logical binary operation: less than");
			:} |
			LARGER_OP 
			{:
				System.out.println("Logical binary operation: greater than");
			:} |
			SMALLER_EQ_OP
			{:
				System.out.println("Logical binary operation: less than or equal to");
			:} |
			LARGER_EQ_OP
			{:
				System.out.println("Logical binary operation: greater than or equal to");
			:} | EQUALS_OP | 
			NOT_EQUALS_OP
			{:
				System.out.println("Logical binary operation: inequality");
			:} | AND_OP | OR_OP;
			
unop ::=	MINUS %prec UMINUS | EXCLAMATION_MARK;

literal ::= INTEGER_LITERAL:n
			{:
				System.out.println("Integer literal: " + n);
			:} |
			STRING_LITERAL:s
			{:
				System.out.println("String literal: " + s);
			:} |
			TRUE_LITERAL:t
			{:
				System.out.println("Boolean literal: " + t);
			:} |
			FALSE_LITERAL:t
			{:
				System.out.println("Boolean literal: " + t);
			:} | NULL_LITERAL;