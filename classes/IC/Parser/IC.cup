package IC.Parser;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import IC.AST.*;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;
	private int arrayDimentionCounter = 0;
	
	private String getValueFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getValue().toString();
	}
	
	private int getLineFromToken(Object obj) {
		Token token = (Token)obj;
		return token.getLine();
	}
	
	public parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	protected class ClassLines
	{
		public ClassLines() 
		{
			methods = new ArrayList<Method>(); 
			new ArrayList<Field>();
		}
		public List<Method> methods;
		public List<Field> fields;
	} 
:}

scan with 
{: 
	Symbol s = lexer.next_token();
	return new Token(s.sym, s.value, s.left, s.right);
:};

/* Terminals (tokens returned by the scanner). */
terminal			ID, CLASS_ID, SEMICOLON, COMMA;

// Keywords
terminal			CLASS_KEYWORD, EXTENDS_KEYWORD, STATIC_KEYWORD, VOID_KEYWORD,
					INT_KEYWORD, BOOLEAN_KEYWORD, STRING_KEYWORD, RETURN_KEYWORD,
					IF_KEYWORD, ELSE_KEYWORD, WHILE_KEYWORD, BREAK_KEYWORD, CONTINUE_KEYWORD,
					THIS_KEYWORD, NEW_KEYWORD, LENGTH_KEYWORD;

// Literals
terminal			TRUE_LITERAL, FALSE_LITERAL, NULL_LITERAL, STRING_LITERAL;
terminal Integer    INTEGER_LITERAL;

// Operators and signs
terminal			LP, RP, LC, RC, LB, RB, DOT, EXCLAMATION_MARK, PLUS, MINUS, MULT,
					DIVIDE, REMINDER, SMALLER_OP, LARGER_OP, SMALLER_EQ_OP, LARGER_EQ_OP,
					EQUALS_OP, NOT_EQUALS_OP, AND_OP, OR_OP, ASSIGN;


// Context terminals
terminal UMINUS;

/* Non terminals */
non terminal Type type, method_type;
non terminal Formal formal;
non terminal List<Formal> formal_list;
non terminal Method method;
non terminal ICClass icClass;
non terminal List<ICClass> icClass_list;
non terminal ClassLines classLines_list;
non terminal Program program;
non terminal List<Field> fields;
non terminal List<String> extra_fields;
non terminal Statement stmnt;
non terminal List<Statement> stmnt_list; 
non terminal Call call;
non terminal Location location;
non terminal Statement elseStmn;
non terminal IC.UnaryOps unop;
non terminal IC.BinaryOps binop;
non terminal Literal literal;
non terminal            
						staticCall, virtualCall,
						extra_exprs;
non terminal Expression expr;

/* Precedences */
precedence left ELSE_KEYWORD;
precedence left DOT;
precedence left SMALLER_OP, LARGER_OP, SMALLER_EQ_OP, LARGER_EQ_OP, 
				EQUALS_OP, NOT_EQUALS_OP, AND_OP, OR_OP;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, REMINDER; 
precedence left ID;
precedence left UMINUS;
precedence left LC, LP;

/* The grammar */
program ::= icClass_list:icCl
			{: RESULT = new Program(icCl); :}
;

icClass_list ::= icClass_list:icCl icClass:icC
				 {: icCl.add(icC); RESULT = icCl; :}
  				 |
  				 {: RESULT = new ArrayList<ICClass>(); :}
;

icClass ::= CLASS_KEYWORD:class_key CLASS_ID:cName EXTENDS_KEYWORD CLASS_ID:superCName LB classLines_list:clines RB
			{: RESULT = new ICClass(getLineFromToken(class_key), getValueFromToken(cName), 
									getValueFromToken(superCName), clines.fields, clines.methods); :} 
			| CLASS_KEYWORD:class_key CLASS_ID:cName LB classLines_list:clines RB
			{: RESULT = new ICClass(getLineFromToken(class_key), getValueFromToken(cName), 
									null, clines.fields, clines.methods); :}
;				


classLines_list ::= classLines_list:clines method:m
					{: clines.methods.add(m); RESULT = clines; :}
					| classLines_list:clines fields:fl
					{: clines.fields.addAll(fl); RESULT = clines; :}
					| 
					{: RESULT = new ClassLines(); :}
;

fields ::=  type:t ID:fName extra_fields:fNamesl
			{: 
				fNamesl.add(0, getValueFromToken(fName));
				List<Field> fields_list = new ArrayList<Field>();
				for (int i = 0; i < fNamesl.size(); i++)
					fields_list.add(new Field(t, fNamesl.get(i))); 
				RESULT = fields_list; 
			:}
;

extra_fields ::= COMMA ID:fName extra_fields:fNamesl
				 {: 
				 	fNamesl.add(0, getValueFromToken(fName));
				 	RESULT = fNamesl;
				 :}
 				| SEMICOLON
 				{: RESULT = new ArrayList<String>(); :}
;

method ::= STATIC_KEYWORD method_type ID:m LP formal_list RP LB stmnt_list RB 
			{:
				System.out.println("Declaration of static method: " + m);
			:}
			| method_type ID:m LP formal_list RP LB stmnt_list RB
			{:
				System.out.println("Declaration of virtual method: " + m);
			:} 
; 

formal_list ::= 
		formal_list:fl COMMA formal:f
		{: ((List<Formal>)fl).add((Formal)f); RESULT = fl; :}
		|
		{: RESULT = new ArrayList<Formal>(); :}
;

formal ::= type:t ID:formalName
		{: RESULT = new Formal((Type)t, getValueFromToken(formalName)); :}
;

method_type ::= VOID_KEYWORD:v
		{: RESULT = new PrimitiveType(getLineFromToken(v), IC.DataTypes.VOID); :}
		| type:t
		{: RESULT = t; :}
;

type ::= type:t LC RC
		{: t.incrementDimension(); RESULT = t; :}
		| INT_KEYWORD:intKey
		{: RESULT = new PrimitiveType(getLineFromToken(intKey), IC.DataTypes.INT); :}
		| BOOLEAN_KEYWORD:boolKey
		{: RESULT = new PrimitiveType(getLineFromToken(boolKey), IC.DataTypes.BOOLEAN); :}
		| STRING_KEYWORD:strKey
		{: RESULT = new PrimitiveType(getLineFromToken(strKey), IC.DataTypes.STRING); :}
		| CLASS_ID:c
		{: RESULT = new UserType(getLineFromToken(c), getValueFromToken(c)); :}
;
			
stmnt_list ::= stmnt_list:sl stmnt:s
	 	{: sl.add(s); RESULT = sl; :}
		| 
		{: RESULT = new ArrayList<Statement>(); :}
; 

stmnt ::= 	location:l ASSIGN expr:exp SEMICOLON 
			{: RESULT = new Assignment(l, exp); :} |
			call:c SEMICOLON
			{: RESULT = new CallStatement(c); :} |
			RETURN_KEYWORD:ret_key SEMICOLON
			{: RESULT = new Return(getLineFromToken(ret_key), null); :} |
			RETURN_KEYWORD:ret_key expr:exp SEMICOLON
			{: RESULT = new Return(getLineFromToken(ret_key), exp); :} |
			IF_KEYWORD LP expr:condExp RP stmnt:doStmn elseStmn:eStmn
			{: RESULT = new If(condExp, doStmn, eStmn); :} |
			WHILE_KEYWORD LP expr:condExp RP stmnt:doStmn 
			{: RESULT = new If(condExp, doStmn); :} |
			BREAK_KEYWORD:break_key SEMICOLON
			{: RESULT = new Break(getLineFromToken(break_key)); :} |
			CONTINUE_KEYWORD:continue_key SEMICOLON
			{: RESULT = new Continue(getLineFromToken(continue_key)); :} |
			LB:lb stmnt_list:sl RB 
			{: RESULT = new StatementsBlock(getLineFromToken(lb), sl); :} |
			type:t ID:vName ASSIGN expr:exp SEMICOLON
			{: RESULT = new LocalVariable(t, getValueFromToken(vName), exp); :}
;

elseStmn ::= ELSE_KEYWORD stmnt:s {: RESULT = s; :} | {: RESULT = null; :} ;
			
expr ::=	location:l {: RESULT = l; :} | call:c {: RESULT = c; :} | 
			THIS_KEYWORD:ths_key
			{: RESULT = new This(getLineFromToken(ths_key)); :} |
			NEW_KEYWORD:n_key CLASS_ID:c LP RP
			{: RESULT = new NewClass(getLineFromToken(n_key), getValueFromToken(c)); :} |
			NEW_KEYWORD type:t LC expr:exp RC
			{: RESULT = new NewArray(t, exp); :} |
			expr:exp DOT LENGTH_KEYWORD
			{: RESULT = new Length(exp); :} | 
			expr:exp1 binop:bOp expr:exp2
			{: RESULT = new LogicalBinaryOp(exp1, bOp, exp2); :} | 
			unop:uOp expr:exp
			{: RESULT = new LogicalUnaryOp(uOp, exp); :} | 
			literal:l {: RESULT = l; :} | LP expr:exp RP {: RESULT = exp; :}
;
	
call ::=	staticCall | virtualCall;

staticCall ::= 	CLASS_ID:c DOT:m ID LP RP
				{:
					System.out.println("Call to static method: " + m + ", in class " + c);
				:} |
				CLASS_ID:c DOT ID:m LP expr extra_exprs RP
				{:
					System.out.println("Call to static method: " + m + ", in class " + c);
				:} ;

virtualCall ::= expr DOT ID:m LP RP
				{:
					System.out.println("Call to virtual method: " + m + ", in external scope");
				:} | 
				ID:m LP RP
				{:
					System.out.println("Call to virtual method: " + m);
				:} |
				expr DOT ID:m LP expr extra_exprs RP
				{:
					System.out.println("Call to virtual method: " + m + ", in external scope");
				:} | 
				ID:m LP expr extra_exprs RP
				{:
					System.out.println("Call to virtual method: " + m);
				:} ;

extra_exprs ::=	COMMA expr extra_exprs | ;

location ::= ID:v
			 {:
			 	System.out.println("Reference to variable: " + v);
			 :} |
			 expr DOT ID:v
			 {:
			 	System.out.println("Reference to variable: " + v + ", in external scope");
			 :} | 
			 expr LC expr RC
			 {:
			 	System.out.println("Reference to array");
			 :} ;

binop ::= 	PLUS 
			{:
				System.out.println("Mathematical binary operation: addition");
			:} |
			MINUS
			{:
				System.out.println("Mathematical binary operation: subtraction");
			:} |
			MULT
			{:
				System.out.println("Mathematical binary operation: multiplication");
			:} | DIVIDE | REMINDER | SMALLER_OP
			{:
				System.out.println("Logical binary operation: less than");
			:} |
			LARGER_OP 
			{:
				System.out.println("Logical binary operation: greater than");
			:} |
			SMALLER_EQ_OP
			{:
				System.out.println("Logical binary operation: less than or equal to");
			:} |
			LARGER_EQ_OP
			{:
				System.out.println("Logical binary operation: greater than or equal to");
			:} | EQUALS_OP | 
			NOT_EQUALS_OP
			{:
				System.out.println("Logical binary operation: inequality");
			:} | AND_OP | OR_OP;
			
unop ::=	MINUS %prec UMINUS | EXCLAMATION_MARK;

literal ::= INTEGER_LITERAL:n
			{:
				System.out.println("Integer literal: " + n);
			:} |
			STRING_LITERAL:s
			{:
				System.out.println("String literal: " + s);
			:} |
			TRUE_LITERAL:t
			{:
				System.out.println("Boolean literal: " + t);
			:} |
			FALSE_LITERAL:t
			{:
				System.out.println("Boolean literal: " + t);
			:} | NULL_LITERAL;